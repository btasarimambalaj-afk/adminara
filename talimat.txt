AdminAra Refactor Projesi – MASTER Uygulama Promptu (Genişletilmiş, 24 Part)
0) Giriş ve Kullanım Talimatı (Projenin Amacı, İşleyiş, Format)

Bağlam:
AdminAra, mevcut bir WebRTC tabanlı admin‑müşteri iletişim sistemi. Şu an Node.js tabanlı (Express, Socket.IO, Redis/BullMQ). AI’nin önerdiği basit username/password yapısını entegre ederek hibrit (Node + FastAPI/Python) hale geçiyoruz. Hedef: Güvenlik, ölçeklenebilirlik ve optimizasyonlar (adaptif bitrate, pil tasarrufu, FIFO kuyruk, sessizlik alert, otomatik raporlar).

Hibrit geçiş için eklenecek alanlar değerlendirilmiş ve ilgili parçalara yerleştirilmiştir: Monitoring & Observability (Prometheus/OpenTelemetry), Multi‑Language Error Handling (ortak logger/Sentry), Authentication Bridge (JWT paylaşımı), WebSocket Failover (reconnection stratejisi), Background Job Koordinasyonu (Celery/BullMQ), Rate Limiting & Throttling (Redis‑based), Caching Layer (shared Redis), Health Check & Readiness Probes (ortak endpoint), Configuration Management (env sync), Performance Monitoring (profiling).

İşleyiş: Refactor 24 part olarak ilerler (senin 1–15 parçan + ek 16–24 parçalar). Kullanıcı her part’ı ayrı mesajda tetikler: “Şimdi Part X’i uygula”. Model her part sonunda:
[PART X BİTTİ] — "Bu kısım tamamlandı. Sonraki part'ı bekliyorum."
diyecek.
Geridönüşümlü (commit‑gibi) değişiklik özeti ve test eklenecek. Eski kod bozulmayacak — hibrit fallback ile korunacak. Kodlar araçlar (code_execution) ile (varsa) test edilecek.

Çıktı formatı (her part için zorunlu):

Değişiklik Özeti (madde madde)

Etkilenen Dosyalar listesi

Kod Snippet’leri (Python/JS; tam, çalışır sözdizimi)

Neden Bu Değişiklik? (1‑2 cümle)

Test Önerisi (manuel ve/veya otomatik)
Son satır: [PART X BİTTİ] — "Bu kısım tamamlandı. Sonraki part'ı bekliyorum."

1) Mevcut Yapı Özeti (Refactor Öncesi) (Senin Metnin)

Düzensiz kök düzeyde Node.js tabanlı:

AdminAra/
├── server.js (ana Express sunucusu, route'lar ve DB bağlantıları karışık, hardcoded creds)
├── routes/index.js (tüm API endpoint'leri: /chat-join, /auth – auth middleware yok)
├── utils/state-store.js (Redis session'ları, Mongo sorguları basit)
├── utils/turn-credentials.js (TURN sunucusu için hardcoded username/password)
├── utils/error-handler.js (global try-catch, logging console'a)
├── socket/admin-auth.js (Socket.IO event'leri: 'join-room', token kontrolü zayıf)
├── public/js/webrtc.js (temel peerConnection, getUserMedia – adaptif yok)
├── public/js/connection-monitor.js (bağlantı ping, pil kontrolü yetersiz)
├── public/js/client.js (müşteri JS, inline event listener'lar)
├── public/css/main.css (temel stiller, mobil responsive değil)
├── public/admin.html (statik admin paneli, chat embed)
├── public/index.html (müşteri giriş sayfası)
├── public/test-suite.html (manuel 5-10 test butonları)
├── service-worker.js (basit cache, offline destek eksik)
├── package.json (bağımlılıklar: express, socket.io, bullmq, redis)
└── (No .env, no tests/ klasörü)


Sorunlar: Güvenlik (creds açık), performans (monolitik, yüksek trafik'te çökme), test eksikliği (%20 coverage).

2) Yeni Yapı Özeti (Refactor Sonrası) (Senin Metnin)

Hibrit (FastAPI + Node kalıntıları), modüler:

AdminAra/
├── README.md (kurulum, run komutları)
├── .env (secrets: DB_URI, TURN_SECRET, REDIS_HOST)
├── requirements.txt (fastapi, uvicorn, celery[redis], pymongo)
├── package.json (react, socket.io-client, jest ekle)
├── main.py (FastAPI app, hibrit Node çağrısı için subprocess)
├── socket.py (Socket.IO FastAPI wrapper)
├── routes/api.py (endpoint'ler: /api/join-queue, JWT auth)
├── utils/state-store.py (Mongo/Redis hibrit)
├── utils/turn-credentials.py (dinamik TURN)
├── utils/error-handler.py (Sentry logging)
├── celery_tasks.py (kuyruklar: rapor, alert)
├── public/src/components/App.jsx (React root)
├── public/src/pages/Index.jsx (bekleme UI)
├── public/src/pages/Admin.jsx (admin dashboard)
├── public/src/pages/Tests.jsx (test runner)
├── public/src/hooks/useSocket.js (WebRTC hook)
├── public/js/webrtc.js (gelişmiş, ekran paylaşımı)
├── public/js/connection-monitor.js (pil optimizasyonu)
├── public/css/main.css (minified, responsive)
├── public/admin.html (React mount)
├── public/index.html (React entry)
├── public/test-suite.html (otomatik runner)
├── service-worker.js (PWA offline)
├── tests/ (unit.js, integration.py, e2e.test.js – 80+ test)
└── config/mermaid-schema.mmd (mimari diyagram)


Değişiklikler: Modülerlik (%50 kod tekrarı azaldı), güvenlik (env + JWT), performans (adaptif WebRTC, lazy‑load).

3) Mimari Şeması (Mermaid) (Senin Metnin)
mermaid
graph TD
A[FastAPI main.py] --> B[socket.py Socket.IO]
C[React App.jsx] --> D[useSocket.js Hook]
B --> E[MongoDB/Redis state-store.py]
D --> F[webrtc.js Peer + TURN]
E --> G[celery_tasks.py Queue: Rapor/Alert]
F --> H[connection-monitor.js Pil]
G --> I[tests/ 80+ Auto]
H --> J[service-worker.js Offline]
I --> K[AdminAra Chat Sistem]

15 Parça — Senin Orijinal Planın (Aynen, ufaltmadan, genişletici notlarla)

Aşağıdaki Part 1–15 bölümleri, senin gönderdiğin metindeki içerikle uyumlu olacak şekilde sunulur; eklediğim notlar (⚠️ veya 💡 ile) senin planını bozmadan yalnızca güçlendirir.

Part 1: Eski Yapı Detaylı Analizi (Güvenlik ve Performans Sorunları)

Senin talimatın (özetle, aynen):
Eski Node.js yapısını baştan sona incele. Odak:

Güvenlik: TURN creds açık, DB URI string, auth yok, token kontrolü zayıf, .env yok.

Performans: webrtc.js fixed bitrate 1Mbps, mobil CPU, ping 5s yetersiz, pil API yok.

Ölçek: BullMQ queue’lar inline, 10+ müşteri memory leak.

Testler: public/test-suite.html manuel, coverage %10.

SW: basit cache; CSS responsive yok.
Adımlar: Dosyaları listele, sorunları kategorize et (güvenlik 5 madde, perf 4 madde), öncelikli fix öner, kırılma noktalarını belirt.
Çıktı: Madde listeler + tablo (dosya | sorun | öncelik). Test: 2 müşteri simülasyonu.

💡 Genişletici notlar: STRIDE tabanlı tehdit modeli çıkar; her risk için C/I/A etkisini ve olasılığı puanla, Top‑10 risk listesi üret. Asset/env envanteri ekle.

Part 2: Yeni Yapı Faydaları ve Ağaç Diyagramı

Senin talimatın: FastAPI + Socket wrapper, Redis/Mongo hibrit state‑store, React context, Celery rapor işleri, .env, bandwidthEstimate event, vs.
Adımlar: Tam tree; her klasör için 2‑3 fayda; eski‑yeni karşılaştırma tablosu.
Test: Dependency graph (manuel).

💡 Genişletici notlar: Diyagrama trust boundary ve X‑Request‑ID akışı ekle.

Part 3: Config ve Env Değişiklikleri

Senin talimatın: .env oluştur (DB_URI, TURN_SECRET, REDIS_HOST, JWT_SECRET, REPORT_EMAIL); main.py dotenv + CORS; requirements.txt, package.json güncelle.
Adımlar & Çıktı: .env şablonu; main.py başlangıç; requirements & package tam listesi.
Test: load_dotenv() + print(os.getenv('DB_URI')).

⚠️ Not: Prod için KMS/Vault entegrasyonu ve secrets rotasyonu Part 17’de.

Part 4: Socket ve Route Refactor

Senin talimatın: socket.py (fastapi_socketio/AsyncServer), JWT decode, auth_ok; routes/api.py join/leave/queue_status; Node server.js fallback (subprocess); JWT paylaşımı Redis; WS reconnection backoff; state Redis pub/sub ile korunur.

💡 Genişletici notlar: WS auth’ta Sec-WebSocket-Protocol: Bearer <JWT> veya same‑site cookie; mesaj şeması (JSON Schema) ve rol‑bazlı guard. Flood koruması.

Part 5: Utils Modülleri Güncellemesi

Senin talimatın: Dinamik TURN (ephemeral user/pwd), hibrit state‑store (Mongo/Redis), Sentry logging, Redis rate limit & caching layer.
Kod: get_turn_creds(), store_session(), handle_error() örnekleri.

⚠️ Not: TURN TTL ≤ 5 dk, domain kısıtı, key rotasyonu ve global+hesap bazlı limiter ayrımı Part 17 ve Part 20’de detaylanır.

Part 6: WebRTC Optimizasyonları

Senin talimatın: RTCPeerConnection + dinamik ICE (TURN), 720p@30 hedef; getDisplayMedia; dataChannel ile offline dosya gönderimi; useSocket ile bandwidth event → setParameters maxBitrate ayarla; battery check entegrasyonu.

💡 Genişletici notlar: ICE restart koşulları, network switch (Wi‑Fi↔LTE), getStats() tabanlı karar; setParameters hata fallback.

Part 7: React Partials Ekleme

Senin talimatın: App.jsx + React Router v6; Index.jsx bekleme UI ve queue position; Admin.jsx sessizlik alert (Web Audio API); mount noktaları.

💡 Genişletici notlar: A11y (WCAG 2.1 AA), i18n, ErrorBoundary ve skeleton/boş durum bileşenleri Part 24’te derinleştirilecek.

Part 8: Celery Tasks ve Kuyruklar

Senin talimatın: celery_tasks.py (Redis broker); nightly_report (PDF + e‑posta, 23:00), silence_alert; BullMQ ile koordine; JSON state transfer.
Genişletme: retries/backoff, acks_late, DLQ, content hash ile idempotency.

Part 9: Test Suite Genişletme

Senin talimatın: tests/ → 80+ test (Jest unit/e2e, Pytest integration); runner JSX; coverage raporu.

💡 Genişletici notlar: Güvenlik testleri (auth bypass, CSRF, rate limit), yük/soak/chaos testleri Part 20’de.

Part 10: Offline ve Mobil İyileştirmeler

Senin talimatın: PWA service worker (install/fetch, offline fallback), Battery API ile düşük güç modu, CSS responsive (@media).
💡 Genişletme: IndexedDB’de şifreli saklama (WebCrypto), quota/temizlik.

Part 11: Bekleme Kuyruğu ve Admin Entegrasyonu

Senin talimatın: Admin’de FIFO kuyruk yönetimi (queue-update, get-queue, pop-queue), Index’te position takibi.
💡 Genişletme: Öncelik/etiket, starvation önleme, eşzamanlı aktif görüşme limiti (token bucket).

Part 12: Tam Entegrasyon ve Hata Testleri

Senin talimatın: main.py → legacy Node çağrısı (subprocess); e2e akış (join→socket→webrtc→silence→report); hata senaryoları (disconnect, retry, ICE restart); JSON logger & çok dilli hata.

💡 Genişletme: Feature flags, RCA şablonu ve runbook girişleri.

Part 13: Deployment ve Monitoring (Tamamlayıcı)

Senin talimatın: Dockerfile (multi-stage Node/Python), Prometheus metrics (utils/metrics.py), README komutları, health/readiness probes, render.yaml.

💡 Genişletme: Zero‑downtime (blue/green), HPA ve rollback akışları Part 22’de.

Part 14: Hibrit Köprüler (Auth, Failover, Caching)

Senin talimatın: utils/bridge.py (JWT Redis paylaşımı, WS failover state transfer), Redis pub/sub ile cache invalidation; env sync YAML overlay.

💡 Genişletme: Token revocation list, clock skew, replay koruması (jti/nonce) → Part 16 ile birlikte çalışır.

Part 15: Monitoring & Performance (Observability, Jobs, Profiling)

Senin talimatın: OTel + Prometheus; Celery/BullMQ transfer finalize; profiling (flame graph).
💡 Genişletme: SLI/SLO ve hata bütçesi tanımları; trace sampling politikası.

Benim Bulduğum Eksikleri Kapatacak Ek Parçalar (16–24)

Aşağıdaki parçalar, yukarıdaki notlarda işaretlediğim tüm boşlukları kapatır. Format, senin parçalarınla aynıdır.

Part 16: RBAC + MFA + Auth Sertleştirme (Şart)

Amaç: Sadece şifreli girişin zayıflıklarını gider; rol bazlı yetki (admin/operator/viewer), MFA (TOTP/WebAuthn), logout & token revocation ekle.

Adımlar:

Rol/İzin Matrisi: config/roles.yaml

resources:
  queue: [read, pop]
  reports: [read, generate]
  users: [read, create, disable]
roles:
  admin:    [queue:read,pop, reports:read,generate, users:read,create,disable]
  operator: [queue:read,pop, reports:read]
  viewer:   [queue:read]


MFA: TOTP (RFC 6238) veya WebAuthn (passkey).
Endpoints:

POST /api/admin/mfa/setup → secret/QR (sadece ilk kurulum)

POST /api/admin/mfa/verify → TOTP doğrulama

Logout & Revocation:

POST /api/admin/logout → Redis revoked:jti:<token> set

Access ≤15 dk, refresh ≤7 gün, rotate refresh

CSRF/CORS: Cookie‑based ise CSRF token; CORS allowlist.

Kod (özet):

# routes/api.py
from fastapi import APIRouter, Depends, HTTPException
from utils.auth import issue_tokens, verify_totp, revoke_jti

@router.post("/api/admin/mfa/verify")
def mfa_verify(code: str = Body(...), user=Depends(require_user)):
    if not verify_totp(user.mfa_secret, code):
        raise HTTPException(401, "MFA invalid")
    return {"ok": True}

@router.post("/api/admin/logout")
def logout(token=Depends(current_access_token)):
    revoke_jti(token["jti"])
    return {"ok": True}


Neden? Prod’da rol ayrımı, ikinci faktör ve revocation olmadan güvenlik hedefi yakalanamaz.
Test: Yanlış TOTP → 401; revoke sonrası token → 401.

Part 17: Secrets & Key Management + TLS + TURN Anahtar Rotasyonu

Amaç: .env’i prod için sertleştir; KMS/Vault, otomatik TLS, TURN ephemeral TTL ve anahtar rotasyonu.

Adımlar:

Secrets Yönetimi:

Staging/prod’da KMS/Vault (örn. AWS KMS/HashiCorp Vault)

JWT_SECRET, TURN_SECRET, DB parolaları buradan çekilir.

TLS & HSTS:

Lets‑Encrypt otomasyonu, auto‑renew

Strict-Transport-Security: max-age=63072000; includeSubDomains; preload

TURN:

Ephemeral cred TTL ≤5 dk

Haftalık key rotate job (Celery/BullMQ)

.env.example + SOPS:

config/secrets.enc.yaml (SOPS/age ile şifreli)

Neden? Sızıntı anında hızlı rotasyon olmadan risk büyür; TLS/HSTS olmadan trafik güvenliği zayıf.
Test: Rotate sonrası eski token/cred geçersiz.

Part 18: API Sözleşmesi, /v1 Versiyonlama, Idempotency, Hata Sözlüğü

Amaç: Geriye dönük uyumluluk ve debug kolaylığı.

Adımlar:

OpenAPI v3: Özel hata modeli

{ "code": "AUTH_401", "message": "Invalid credentials", "correlationId": "..." }


Versiyonlama: Tüm uçlar /v1 prefix ile.

Idempotency-Key: Yazma uçlarında başlık desteği; Redis’te 24 saat cache.

Correlation‑ID Middleware: X-Request-ID üret/döndür.

Neden? Sözleşme ve idempotency olmadan entegrasyon kırılmaları yaşanır.
Test: Aynı Idempotency-Key ile iki POST → tek kaynak.

Part 19: KVKK/GDPR – Onay, Retention, Maskeleme, At‑Rest Şifreleme

Amaç: Çağrı kayıtları ve log PDF’leri için hukukî ve teknik kontroller.

Adımlar:

Onay Akışı: Müşteri arayüzünde kayıt/onay checkbox + audit trail.

Retention: Varsayılan 30/90 gün; Celery job ile sil/anonimleştir.

Şifreleme: Dosya/DB için AES‑GCM (anahtar KMS); transit TLS.

DLP & Maskeleme: Log ve raporlarda PII maskeleme, opt‑out.

Neden? Uyumsuzluk riski yüksek; müşteri güveni için şart.
Test: Süresi dolan kayda erişim reddi; raporlarda PII maskesi.

Part 20: Yük/Soak/Chaos Testleri ve Performans Bütçeleri

Amaç: Gerçek koşullarda dayanıklılık; SLO’ları doğrulama.

Adımlar:

Performans Bütçeleri:

p95 join→call ≤ 5 sn

ICE success rate ≥ %98

Login success ≥ %99.5

k6/Locust senaryoları: /api/join-queue, WS connect, offer/answer, datachannel.

Chaos: %5 paket kaybı, 200 ms jitter, pod kill; SLO ihlali alarmı.

Örnek k6 iskeleti:

import http from 'k6/http';
import { check, sleep } from 'k6';
export let options = { vus: 50, duration: '3m' };
export default function () {
  const res = http.post('https://.../v1/api/join-queue', JSON.stringify({user_id:'k6'}), { headers: { 'Content-Type': 'application/json' }});
  check(res, { '200': (r) => r.status === 200 });
  sleep(1);
}


Neden? Kapasite planı ve zayıf halkaların bulunması için zorunlu.
Test: Rapor: p95/99, error rate, SLA breach alarmı.

Part 21: CI/CD & Güvenlik Taramaları (SAST/DAST, SBOM, Image Scan)

Amaç: Her merge’de prod kalitesine yakın güven.

Adımlar:

Pipeline: lint (flake8/eslint), test (Jest/Pytest), coverage ≥ %85, build, image scan.

SAST/DAST: Semgrep + OWASP ZAP; raporları artifact et.

SBOM: Syft + Grype; bağımlılık zafiyetleri.

Pre‑commit: black/isort/eslint + husky.

Örnek GitHub Actions (özet):

name: ci
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
      - run: pip install -r requirements.txt
      - run: pip install pytest
      - run: pytest -q
      - uses: actions/setup-node@v4
      - run: npm ci && npm test -- --ci --reporters=default


Neden? Regresyon ve güvenlik açıklarını erken yakalamak.
Test: Coverage < %85 → pipeline kırılmalı.

Part 22: Orkestrasyon & SRE (K8s, HPA, Rolling/Blue‑Green, Runbook)

Amaç: %99+ uptime, ölçeklenebilir ve güvenli yaygınlaştırma.

Adımlar:

K8s Manifests: Deployment, Service, Ingress(TLS), ConfigMap/Secret; liveness/readiness.

HPA: CPU ve/veya latency tabanlı; TURN, API ayrı ölçeklenir.

Rollout: RollingUpdate; blue/green seçeneği; otomatik rollback.

Runbook & RCA: Arıza sınıfları, playbook, RCA şablonu.

Örnek HPA (özet):

apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
spec:
  minReplicas: 2
  maxReplicas: 10
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70


Neden? Trafik dalgalanmalarında stabilite.
Test: Canary %10 → %100; hata durumunda rollback.

Part 23: SFU Yol Haritası (mediasoup/Janus) – Ölçek İçin

Amaç: P2P’den SFU mimarisine geçiş opsiyonu (çok katılımcı, yüksek eşzamanlı).

Adımlar:

Deneysel Bayrak: FEATURE_SFU=true iken SFU path; aksi P2P.

Signaling Genişletme: join_sfu_room, publish/subscribe semantiği.

Kaynak Yönetimi: Simulcast/SVC, bitrate katmanları, server‑side adaptasyon.

Metrikler: SFU CPU, publisher/subscriber sayıları, e2e latency.

Neden? Büyüyen trafik için sürdürülebilir kalite.
Test: 1 admin + 10+ müşteri senaryosu; p95 medya gecikmesi.

Part 24: A11y & i18n & UX Dayanıklılığı

Amaç: Erişilebilirlik (WCAG 2.1 AA), çok dilli arayüz, hataya dayanıklı UX.

Adımlar:

A11y: Odak görünürlüğü, klavye navigasyonu, ARIA etiketleri, kontrast ≥ 4.5:1.

i18n: i18next (en/tr), tarih/sayı yerelleştirme.

ErrorBoundary & Boş Durumlar: Tüm sayfalarda; skeleton yükleme; offline banner.

Form Doğrulama: Client‑side schema, ekran okuyucu dostu hata mesajları.

Neden? Daha geniş kullanıcı kitlesi, daha düşük destek maliyeti.
Test: Axe-core ile A11y denetimi; dil değiştirme persistansı.

Global Kabul Kriterleri ve Kalite Kapıları (Tüm Parçalar İçin)

Güvenlik Başlıkları:
Strict-Transport-Security, Content-Security-Policy (nonce’lu, dış kaynak allowlist), X-Frame-Options: DENY, Referrer-Policy: no-referrer, X-Content-Type-Options: nosniff.

Cookie Bayrakları: HttpOnly, Secure, SameSite=Lax/Strict.

JWT: short‑lived access, refresh rotate, revocation list, jti, nbf, clock skew toleransı, replay koruması.

WS Güvenliği: Handshake’de auth; mesaj başına yetki & şema doğrulama; rate/flood limit.

TURN/STUN: Ephemeral TTL ≤ 5 dk, key rotasyonu, bölge/failover; metriklerle ICE success ≥ %98.

Observability: X‑Request‑ID, structured logs (JSON), OTel tracing + Prometheus metrics, SLO’lar (login success, ICE success, p95 join→call).

Test Eşiği: Coverage ≥ %85; güvenlik testleri; yük/soak/chaos raporları.

Uyum: Onay, retention, şifreleme, maskeleme; DLP kuralları.

Dağıtım: K8s + HPA; zero‑downtime rollout; rollback; runbook & RCA.

Ek Örnek Snippet’ler (Hızlı Uygulama İçin)

CSP (örnek, sıkılaştırılacak):

Content-Security-Policy: default-src 'self'; script-src 'self' 'nonce-<RANDOM>'; connect-src 'self' wss://<domain>; img-src 'self' data:; style-src 'self' 'unsafe-inline'


Idempotency Middleware (FastAPI, özet):

@app.middleware("http")
async def idempotency(request: Request, call_next):
    key = request.headers.get("Idempotency-Key")
    if request.method in ("POST","PUT","PATCH") and key:
        cache_key = f"idemp:{key}"
        if await redis.exists(cache_key):
            return JSONResponse(await redis.get(cache_key), status_code=200)
        resp = await call_next(request)
        if resp.status_code in (200,201):
            await redis.setex(cache_key, 86400, await resp.body())
        return resp
    return await call_next(request)


WS Auth (özet):

@sio.event
async def connect(sid, environ, auth):
    token = auth.get("token") or environ.get("HTTP_SEC_WEBSOCKET_PROTOCOL_TOKEN")
    user = verify_jwt(token)
    if not user: return False
    await sio.save_session(sid, {"uid": user["sub"], "role": user["role"]})


Redis Rate Limit (IP + hesap):

def rate_limit(key, limit, window=60):
    now = int(time.time())
    pipe = redis.pipeline()
    pipe.zadd(key, {now: now})
    pipe.zremrangebyscore(key, 0, now-window)
    pipe.zcard(key)
    pipe.expire(key, window)
    _,_,count,_ = pipe.execute()
    return count <= limit

Nasıl Kullanacaksın?

Bu MASTER promptu aynen (blok halinde) diğer yapay zekâ aracına ver.

“Tüm part’lar için hazırım. Part 1’i gönder.” diye başlasın.

Her partı tek tek ver: “Şimdi Part X’i uygula”.

Her part sonunda modelin şu satırı döndürmesini zorunlu kıl:
[PART X BİTTİ] — "Bu kısım tamamlandı. Sonraki part'ı bekliyorum."

1–15 bittiğinde 16–24 ile benim tespit ettiğim tüm eksikler de kapanmış olacak.